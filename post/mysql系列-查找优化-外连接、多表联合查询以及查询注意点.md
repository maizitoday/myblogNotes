---
title:       "查找优化-外连接、多表联合查询以及查询注意点"
subtitle:    ""
description: ""
date:        2019-08-26
author:      "麦子"
image:       "https://c.pxhere.com/images/e8/66/3d717bad8449de9495d9c9761d57-1423465.jpg!d"
tags:        ["mysql系列", "外连接、多表联合查询","查询注意点","查询小技巧"]
categories:  ["Tech" ]
---

[TOC]

**转载地址：https://blog.csdn.net/jack__frost/article/details/71698285**

# 实验表

## 学生表

| id   | name | sex  | age  |
| ---- | ---- | ---- | ---- |
| 1    | 小强 | 男   | 8    |
| 2    | 小花 | 女   | 5    |
| 3    | 小名 | 女   | 6    |
| 4    | 小五 | 女   | 6    |

| **5** | **小星** | **男** | **30** |
| ----- | -------- | ------ | ------ |
|       |          |        |        |

## 学分表

| id   | classType | teacher | number | sid  |
| ---- | --------- | ------- | ------ | ---- |
| 1    | 物理      | 王老师  | 90     | 1    |
| 2    | 数学      | 李老师  | 70     | 2    |
| 3    | 英语      | 黄老师  | 80     | 3    |
| 4    | 体育      | 易老师  | 99     | 4    |
| 5    | 化学      | 科老师  | 50     | 4    |
| 6    | 语文      | 张老师  | 88     | 2    |

| 7    | 地理 | 地老师 | 60   | 6    |
| ---- | ---- | ------ | ---- | ---- |
| 8    | 历史 | 历老师 | 65   | 7    |

# 基本连接方法

## 内连接

用比较运算符根据每个表**共有的列的值**匹配两个表中的行（=或>、<）

```sql
select * from  school.student  stu
         inner join school.score sco on  stu.id = sco.sid 
```

查询数据如下：

| 1    | 小强 | 男   | 8    | 1    | 物理 | 王老师 | 90   | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
| 2    | 小花 | 女   | 5    | 2    | 数学 | 李老师 | 70   | 2    |
| 3    | 小名 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 4    | 小五 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |
| 4    | 小五 | 女   | 6    | 5    | 化学 | 科老师 | 50   | 4    |
| 2    | 小花 | 女   | 5    | 6    | 语文 | 张老师 | 88   | 2    |

**很容器看出是两者都满足才查出，7 和 8 没有对应的所以没有出来。**



## 外连接之左连接

首先是左表数据全部罗列，然后有满足条件的右表数据都会全部罗列出。**若两条右表数据对左表一条数据，则会用对应好的左表数据补足作为一条记录。**

```sql
select * from  school.student  stu
         left join school.score sco on  stu.id = sco.sid 
```

查询数据如下：

| 1    | 小强 | 男   | 8    | 1    | 物理 | 王老师 | 90   | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
| 2    | 小花 | 女   | 5    | 2    | 数学 | 李老师 | 70   | 2    |
| 3    | 小名 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 4    | 小五 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |
| 4    | 小五 | 女   | 6    | 5    | 化学 | 科老师 | 50   | 4    |
| 2    | 小花 | 女   | 5    | 6    | 语文 | 张老师 | 88   | 2    |
| 5    | 小星 | 男   | 30   |      |      |        |      |      |

### 左连接升级

**[left join 或者left outer join(等同于left join)] + [where B.column is null], 查出和两张表中没有关联的数据。

```sql
select * from  school.student  stu
         left join school.score sco on  stu.id = sco.sid 
         where sco.sid is null 
```

查询数据如下：

| 5    | 小星 | 男   | 30   |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |



## 外连接之右连接

与左连恰恰相反，首先是右表数据全部罗列，**然后有满足条件的左表数据都会全部罗列出。若两条左表数据对右表一条数据，则会用对应好的右表数据补足作为一条记录。**

```sql
select * from  school.student  stu
         right join school.score sco on  stu.id = sco.sid 
```

查询数据如下：

| 1    | 小强 | 男   | 8    | 1     | 物理     | 王老师     | 90     | 1     |
| ---- | ---- | ---- | ---- | ----- | -------- | ---------- | ------ | ----- |
| 2    | 小花 | 女   | 5    | **2** | **数学** | **李老师** | **70** | **2** |
| 3    | 小名 | 女   | 6    | **3** | **英语** | **黄老师** | **80** | **3** |
| 4    | 小五 | 女   | 6    | **4** | **体育** | **易老师** | **99** | **4** |
| 4    | 小五 | 女   | 6    | **5** | **化学** | **科老师** | **50** | **4** |
| 2    | 小花 | 女   | 5    | **6** | **语文** | **张老师** | **88** | **2** |
|      |      |      |      | **7** | **地理** | **地老师** | **60** | **6** |
|      |      |      |      | **8** | **历史** | **历老师** | **65** | **7** |



### 右连接升级

查出和两张表中没有关联的数据。

```sql
select * from  school.student  stu
         right join school.score sco on  stu.id = sco.sid 
         where stu.id is null
```

查询数据如下：

|      |      |      |      | 7     | 地理     | 地老师     | 60     | 6     |
| ---- | ---- | ---- | ---- | ----- | -------- | ---------- | ------ | ----- |
|      |      |      |      | **8** | **历史** | **历老师** | **65** | **7** |



## 外连接之全外连接

full join （mysql不支持，但是可以用 left join union right join代替）

```sql
select * from  school.student  stu
         left join school.score sco on  stu.id = sco.sid 
        
         union
         
select * from  school.student  stu
         right join school.score sco on  stu.id = sco.sid 
```

查询数据如下：

| 1    | 小强 | 男   | 8    | 1    | 物理 | 王老师 | 90   | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
| 2    | 小花 | 女   | 5    | 2    | 数学 | 李老师 | 70   | 2    |
| 3    | 小名 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 4    | 小五 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |
| 4    | 小五 | 女   | 6    | 5    | 化学 | 科老师 | 50   | 4    |
| 2    | 小花 | 女   | 5    | 6    | 语文 | 张老师 | 88   | 2    |
| 5    | 小星 | 男   | 30   |      |      |        |      |      |
|      |      |      |      | 7    | 地理 | 地老师 | 60   | 6    |
|      |      |      |      | 8    | 历史 | 历老师 | 65   | 7    |

因为只要满足 union上面的sql或者下面的sql一种情况就ok了。 如下我们可以升级,查询出两种表中没有关系的数据：

```sql
select * from  school.student  stu
         left join school.score sco on  stu.id = sco.sid 
         where sco.sid is null 
         union
         
select * from  school.student  stu
         right join school.score sco on  stu.id = sco.sid 
         where stu.id is null
```

查询数据如下：

| 5    | 小星 | 男   | 30   |      |      |        |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
|      |      |      |      | 7    | 地理 | 地老师 | 60   | 6    |
|      |      |      |      | 8    | 历史 | 历老师 | 65   | 7    |



## 交叉连接

交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。

### 显式的交叉连接：A，B表记录的排列组合，即笛卡儿积。

```sql
select * from  school.student  stu
         cross join school.score
         order by stu.id
```

查询数据如下：

| 1    | 小强 | 男   | 8    | 3    | 英语 | 黄老师 | 80   | 3    |
| ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
| 1    | 小强 | 男   | 8    | 8    | 历史 | 历老师 | 65   | 7    |
| 1    | 小强 | 男   | 8    | 5    | 化学 | 科老师 | 50   | 4    |
| 1    | 小强 | 男   | 8    | 2    | 数学 | 李老师 | 70   | 2    |
| 1    | 小强 | 男   | 8    | 7    | 地理 | 地老师 | 60   | 6    |
| 1    | 小强 | 男   | 8    | 4    | 体育 | 易老师 | 99   | 4    |
| 1    | 小强 | 男   | 8    | 1    | 物理 | 王老师 | 90   | 1    |
| 1    | 小强 | 男   | 8    | 6    | 语文 | 张老师 | 88   | 2    |
| 2    | 小花 | 女   | 5    | 6    | 语文 | 张老师 | 88   | 2    |
| 2    | 小花 | 女   | 5    | 3    | 英语 | 黄老师 | 80   | 3    |
| 2    | 小花 | 女   | 5    | 8    | 历史 | 历老师 | 65   | 7    |
| 2    | 小花 | 女   | 5    | 5    | 化学 | 科老师 | 50   | 4    |
| 2    | 小花 | 女   | 5    | 2    | 数学 | 李老师 | 70   | 2    |
| 2    | 小花 | 女   | 5    | 7    | 地理 | 地老师 | 60   | 6    |
| 2    | 小花 | 女   | 5    | 4    | 体育 | 易老师 | 99   | 4    |
| 2    | 小花 | 女   | 5    | 1    | 物理 | 王老师 | 90   | 1    |
| 3    | 小名 | 女   | 6    | 1    | 物理 | 王老师 | 90   | 1    |
| 3    | 小名 | 女   | 6    | 6    | 语文 | 张老师 | 88   | 2    |
| 3    | 小名 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 3    | 小名 | 女   | 6    | 8    | 历史 | 历老师 | 65   | 7    |
| 3    | 小名 | 女   | 6    | 5    | 化学 | 科老师 | 50   | 4    |
| 3    | 小名 | 女   | 6    | 2    | 数学 | 李老师 | 70   | 2    |
| 3    | 小名 | 女   | 6    | 7    | 地理 | 地老师 | 60   | 6    |
| 3    | 小名 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |
| 4    | 小五 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |
| 4    | 小五 | 女   | 6    | 1    | 物理 | 王老师 | 90   | 1    |
| 4    | 小五 | 女   | 6    | 6    | 语文 | 张老师 | 88   | 2    |
| 4    | 小五 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 4    | 小五 | 女   | 6    | 8    | 历史 | 历老师 | 65   | 7    |
| 4    | 小五 | 女   | 6    | 5    | 化学 | 科老师 | 50   | 4    |
| 4    | 小五 | 女   | 6    | 2    | 数学 | 李老师 | 70   | 2    |
| 4    | 小五 | 女   | 6    | 7    | 地理 | 地老师 | 60   | 6    |
| 5    | 小星 | 男   | 30   | 7    | 地理 | 地老师 | 60   | 6    |
| 5    | 小星 | 男   | 30   | 4    | 体育 | 易老师 | 99   | 4    |
| 5    | 小星 | 男   | 30   | 1    | 物理 | 王老师 | 90   | 1    |
| 5    | 小星 | 男   | 30   | 6    | 语文 | 张老师 | 88   | 2    |
| 5    | 小星 | 男   | 30   | 3    | 英语 | 黄老师 | 80   | 3    |
| 5    | 小星 | 男   | 30   | 8    | 历史 | 历老师 | 65   | 7    |
| 5    | 小星 | 男   | 30   | 5    | 化学 | 科老师 | 50   | 4    |
| 5    | 小星 | 男   | 30   | 2    | 数学 | 李老师 | 70   | 2    |

可以看到， 左边的表5条数据， 每一条对应右边的8条数据， 5*8=40条数据。 

```sql
select * from  school.student  stu
         cross join school.score sc 
         where stu.id = sc.sid
         order by stu.id
```

转成内连接，查询如下数据：

| 1    | 小强 | 男   | 8    | 1    | 物理 | 王老师 | 90   | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
| 2    | 小花 | 女   | 5    | 6    | 语文 | 张老师 | 88   | 2    |
| 2    | 小花 | 女   | 5    | 2    | 数学 | 李老师 | 70   | 2    |
| 3    | 小名 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 4    | 小五 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |
| 4    | 小五 | 女   | 6    | 5    | 化学 | 科老师 | 50   | 4    |



### 隐式的交叉连接，没有CROSS JOIN

```sql
select * from  school.student  stu, school.score sc 
         where stu.id = sc.sid
         order by stu.id
```

和上面的显示交叉结果数据一样。 

| 1    | 小强 | 男   | 8    | 1    | 物理 | 王老师 | 90   | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
| 2    | 小花 | 女   | 5    | 6    | 语文 | 张老师 | 88   | 2    |
| 2    | 小花 | 女   | 5    | 2    | 数学 | 李老师 | 70   | 2    |
| 3    | 小名 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 4    | 小五 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |
| 4    | 小五 | 女   | 6    | 5    | 化学 | 科老师 | 50   | 4    |

# 超大型数据优化



## 超大型数据尽可能尽力不要写子查询，使用连接（JOIN）去替换它



## 使用联合(UNION)来代替手动创建的临时表

**UNION是会把结果排序**，union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中（即把两次或多次查询结果合并起来。）。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。

### 要求

两次查询的列数必须一致

### 推荐

列的类型可以不一样，但推荐查询的每一列，想对应的类型以一样

### 可以来自多张表的数据

多次sql语句取出的列名可以不一致，此时以第一个sql语句的列名为准。

如果不同的语句中取出的行，有完全相同(这里表示的是每个列的值都相同)，那么union会将相同的行合并，最终只保留一行。也可以这样理解，union会去掉重复的行。**如果不想去掉重复的行，可以使用union all。**

如果子句中有**order by,limit，需用括号()包起来**。推荐放到所有子句之后，即对最终合并的结果来排序或筛选。

```sql
(select * from  school.student  stu
         left join school.score sco on  stu.id = sco.sid 
         limit 0,4) 
         
         union
         
(select * from  school.student  stu
         right join school.score sco on  stu.id = sco.sid 
          limit 0,4 )
```

这里student的表中只有4条是score表中对应的，所以如此后，就合并成一条了， 查询如下数据：

| 1    | 小强 | 男   | 8    | 1    | 物理 | 王老师 | 90   | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
| 2    | 小花 | 女   | 5    | 2    | 数学 | 李老师 | 70   | 2    |
| 3    | 小名 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 4    | 小五 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |

 

### 注意

1、UNION 结果集中的列名总是等于第一个 SELECT 语句中的列名。

2、UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。



## UNION ALL的作用和语法

默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。

```sql
(select * from  school.student  stu
         left join school.score sco on  stu.id = sco.sid 
         limit 0,4) 
         union ALL
         
(select * from  school.student  stu
         right join school.score sco on  stu.id = sco.sid 
          limit 0,4)
```

查询数据如下：

| 1    | 小强 | 男   | 8    | 1    | 物理 | 王老师 | 90   | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ------ | ---- | ---- |
| 2    | 小花 | 女   | 5    | 2    | 数学 | 李老师 | 70   | 2    |
| 3    | 小名 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 4    | 小五 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |
| 1    | 小强 | 男   | 8    | 1    | 物理 | 王老师 | 90   | 1    |
| 2    | 小花 | 女   | 5    | 2    | 数学 | 李老师 | 70   | 2    |
| 3    | 小名 | 女   | 6    | 3    | 英语 | 黄老师 | 80   | 3    |
| 4    | 小五 | 女   | 6    | 4    | 体育 | 易老师 | 99   | 4    |



# 查询编写的优化点

## 对查询进行优化，要尽量避免全表扫描

首先应考虑在 where 及 order by 涉及的列上建立索引。



## 应尽量避免在 where 子句中对字段进行 null 值判断

否则将导致引擎放弃使用索引而进行全表扫描，如：

```sql
//最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.
select id from t where num is null
```

不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，**如果是varchar这样的变长字段， null 不占用空间。**可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：

```sql
select id from t where num = 0
```



## in 和 not in 也要慎用，否则会导致全表扫描

```sql
select id from t where num in(1,2,3)
```

对于连续的数值，能用 between 就不要用 in 了：

```sql
select id from t where num between 1 and 3		
```

很多时候用 exists 代替 in 是一个好的选择：

```sql
select num from a where num in(select num from b)
//用这个去替换
select num from a where exists(select 1 from b where num=a.num)
```



## like全表扫描

```sql
select id from t where name like ‘%abc%’
```

**上面这种查询也将导致全表扫描，若要提高效率，可以考虑全文检索。**



## 尽量使用数字型字段

若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。



## select * from t 

任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。



## 尽量使用表变量来代替临时表。

如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。



## 在Join表的时候使用相当类型的例，并将其索引

如果你的应用程序有很多 JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。

而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把 DECIMAL 字段和一个 INT 字段Join在一起，MySQL就无法使用它们的索引。对于那些STRING类型，还需要有相同的字符集才行。（两个表的字符集有可能不一样）

```sql
//在state中查找company
SELECT company_name FROM users
    LEFT JOIN companies ON (users.state = companies.state)
    WHERE users.id = $user_id"
    //两个 state 字段应该是被建过索引的，而且应该是相当的类型，相同的字符集
```

