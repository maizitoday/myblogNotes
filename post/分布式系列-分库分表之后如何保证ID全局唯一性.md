---
title:       "分库分表之后如何保证ID全局唯一性"
subtitle:    ""
description: ""
date:        2019-05-21
author:      "麦子"
image:       "https://c.pxhere.com/images/20/93/7f06e2f103e3f5a5b7cfcffaa709-1433419.jpg!d"
tags:        ["分布式系列", "ID全局唯一性"]
categories:  ["Tech" ]
---

[TOC]

**说明： 原文地址https://blog.csdn.net/bjweimengshu/article/details/80162731**

# 常见几种方式

## UUID

虽然可以保证全局唯一，但是占用32位有些太长，而且是无序的，入库时性能较差。

## 数据库主键

 ID的生成对数据库的严重依赖，不但影响性能，而且一旦数据库挂掉，服务将变的不可用。

## 分布式锁

性能不行。 

# SnowFlake算法

snowflake算法所生成的ID结构是什么样子呢？我们来看看下图：

![5-21-11](/img/5-21-11.jpeg)

SnowFlake所生成的ID一共分成四部分：

**第一位**：占用1bit，其值始终是0，没有实际作用。

**时间戳**：占用41bit，精确到毫秒，总共可以容纳约140年的时间。

**工作机器id**：占用10bit，其中高位5bit是数据中心ID（datacenterId），低位5bit是工作节点ID（workerId），做多可以容纳1024个节点。

**序列号**：占用12bit，这个值在同一毫秒同一节点上从0开始不断累加，最多可以累加到4095。

SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？只需要做一个简单的乘法：**同一毫秒的ID数量 = 1024 X 4096 =  4194304**，这个数字在绝大多数并发场景下都是够用的。

# SnowFlake的优势和劣势



## 优点

1.  生成ID时不依赖于DB，完全在内存生成，高性能高可用。
2.  ID呈趋势递增，后续插入索引树的时候性能较好。
3.  每个ID中都可以解读出，该ID是在哪个数据中心的哪台工作机器上产生
4.  数值型的分布式ID（替换了UUID）
5.  高性能的ID生成器（超高400w/s的超高性能）



## 缺点

依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。



# 实现

<https://gitee.com/wayz/snowflake>